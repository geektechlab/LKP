Theory0:
Return value of system calls
----------------------------

Returning 0, notifies the calling process that the system call succeeded and that no errors occurred

Returning errors: a negated value from the <errno.h> header file should be returned, indicating what type of error occurred

The system C library will automatically take that negative value and put the appropriate value in the errno variable in user-space (and return -1 from the function).

Theory1:
System call which accepts a string argument, logs it on the kernel buffer
-----------------------------------------------------------------------------

As our system call has one argument, we use SYSCALL_DEFINE1, and our only parameter is a char * which we name string

Step1: Update my_syscalls/hello.c file

SYSCALL_DEFINE1(hello_str, const char __user *, string){
        char user_msg[256];
	pr_info("%s\n", __func__);
        long copied = strncpy_from_user(user_msg, string, sizeof(user_msg));
        if (copied < 0 || copied == sizeof(user_msg))
                return -EFAULT;
        pr_info("%s\n",user_msg);
        return 0;
}

We are using strncpy_from_user, since we cannot directly access user space memory in kernel space

strncpy_from_user behaves like normal strncpy, but checks the user-space memory address first.

If the string was too long or if there was a problem copying, we return EFAULT

Step2: Update system call table

Step3: Update include/linux/syscalls.h file

Step4: Compile and install the kernel

Theory2:
What happens if i pass a different type of argument?
======================================================
it fails with errornum

Theory3:
Generic System Call Table
--------------------------

Some architectures (e.g. x86) have their own architecture-specific syscall tables

Several other architectures share a generic syscall table.

For your system call to be used by multiple architectures.

Add your new system call to the generic list by adding an entry to the list in include/uapi/asm-generic/unistd.h

#define __NR_hello 434
__SYSCALL(__NR_hello, sys_hello)

Also update the __NR_syscalls count to reflect the additional system call

#define __NR_syscalls 435

Theory4:
What happens when we compile the user space application for 32-bit will the code works?
========================================================================================

There are two 32-bit ABIs that can be supported by 64-bit x86 kernels, in addition to the native x86-64 ABI

The 32-bit ABIs are:

	1. The i386 ABI that emulates the ABI implemented by 32-bit x86 kernels.
	2. The x32 ABI that is a newer 32-bit ABI for x86-64 kernels.

gcc -m32 flag will generate code for the i386 ABI
gcc -mx32 flag will generate code for the x32 ABI.

The "syscall_64.tbl" file enumerates the system calls for the x86-64 and x32 ABIs:
The "64" entries are for the x64-64 ABI.
The "x32" entries are for the x32 ABI.
The "common" entries are for both the x64-64 and x32 ABI

The "syscall_32.tbl" enumerates the system calls for the i386 ABI.

For each system call number, the table lists two entry points:
	1.The entry point for 32-bit x86 kernels.
	2.The "compat" entry point for i386 ABI emulation on x86-64 kernels.

Some obsolete system calls that are no longer implemented by the kernel are listed without an entry point.

You need to add entry into arch/x86/entry/syscalls/syscall_32.tbl
434	i386	hello	sys_hello

Note: Applications using the x32 ABI won't run on systems with 32-bit kernels.

Theory5:
How is __ia32_sys_hello map to __x64_sys_hello
-----------------------------------------------

In arch/x86/include/asm/syscall_wrapper.h, SYSCALL_DEFINE0 creates an alias for the real 64-bit application

/*
 * To keep the naming coherent, re-define SYSCALL_DEFINE0 to create an alias
 * named __ia32_sys_*()
 */

#define SYSCALL_DEFINE0(sname)					\
	SYSCALL_METADATA(_##sname, 0);				\
	asmlinkage long __x64_sys_##sname(void);		\
	ALLOW_ERROR_INJECTION(__x64_sys_##sname, ERRNO);	\
	SYSCALL_ALIAS(__ia32_sys_##sname, __x64_sys_##sname);	\
	asmlinkage long __x64_sys_##sname(void)

Theory6:
System Call Table
---------------------

The system call table is represented by the sys_call_table array

Defined: arch/x86/entry/syscall_64.c

asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
        /*
         * Smells like a compiler bug -- it doesn't work
         * when the & below is removed.
         */
        [0 ... __NR_syscall_max] = &sys_ni_syscall,
#include <asm/syscalls_64.h>
};

You can see, sys_call_table is an array of __NR_syscall_max + 1 size 

__NR_syscall_max macro represents the maximum number of system calls for the given architecture

this macro in the header file generated by Kbuild during kernel compilation

on x86_64

./include/generated/asm-offsets.h:43:#define __NR_syscall_max 547 /* sizeof(syscalls_64) - 1 */

sys_call_ptr_t -->  typedef asmlinkage long (*sys_call_ptr_t)(const struct pt_regs *);

Initialization of sys_call_table
--------------------------------

all elements of array that contain pointers to the system call handlers point to the sys_ni_syscall

The sys_ni_syscall function represents not-implemented system calls

Implementation of the sys_ni_syscall is pretty easy, it just returns -errno or -ENOSYS in our case

 To start with, all elements of the sys_call_table array point to the not-implemented system call

...	-->	a GCC compiler extension called - Designated Initializers allows us to initialize elements in non-fixed order

we included the asm/syscalls_64.h header at the end of the array

This header file is generated by the special script at arch/x86/entry/syscalls/syscalltbl.sh and generates our header file from the syscall table.

./arch/x86/include/generated/asm/syscalls_64.h
./arch/x86/include/generated/asm/syscalls_32.h

Theory7:
Compatibility System Calls
------------------------------

Most 64-bit implementations of system calls work fine when the user space program is 32-bit

There are a couple of situations where a compatibility layer is needed to cope with size differences between 32-bit and 64-bit

This is needed whenever a system call argument is

	a pointer to a pointer
	a pointer to a struct containing a pointer (e.g. struct iovec __user *)
	a pointer to a varying sized integral type (time_t, off_t, long, ...)
	a pointer to a struct containing a varying sized integral type.

The second situation that requires a compatibility layer is if one of the system callâ€™s arguments has a type that is explicitly 64-bit even on a 32-bit architecture, for example loff_t or __u64.

In this case, a value that arrives at a 64-bit kernel from a 32-bit application will be split into two 32-bit values, which then need to be re-assembled in the compatibility layer.

COMPAT_SYSCALL_DEFINEn
------------------------

The compatibility version of the system call is called compat_sys_xyzzy(), and is added with the COMPAT_SYSCALL_DEFINEn() macro, analogously to SYSCALL_DEFINEn

This version of the implementation runs as part of a 64-bit kernel, but expects to receive 32-bit parameter values and does whatever is needed to deal with them

Typically, the compat_sys_ version converts the values to 64-bit versions and either calls on to the sys_ version, or both of them call a common inner implementation function

The compat entry point also needs a corresponding function prototype, in include/linux/compat.h,

asmlinkage long compat_sys_xyzzy(...);
