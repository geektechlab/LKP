Theory0:
Inline Assembly
----------------

In Linux Kernel, you normally see statements like:

asm volatile ("outb %al, $0x80");

asm volatile("mov %%cr0,%0" : "=r" (cr0));

This is inline assembly. In other words assembly code integrated in C/C++ language.

Advantages of Inline Assembly
------------------------------

a) Optimization:

	Programmers can use assembly language code to implement the most performance-sensitive parts of their program's algorithms
	code that is apt to be more efficient than what might otherwise be generated by the compiler

b) Access to processor specific instructions:

	Most processors offer special instructions, such as Compare and Swap and Test and Set instructions which may be used to construct semaphores or other synchronization and locking primitives

c) System calls: High-level languages rarely have a direct facility to make arbitrary system calls, so assembly code is used.

d) Inline assembly code can use any C variable or function name that is in scope, so it is easy to integrate it with your C code

Theory1:
Example of speed with inline assembly
---------------------------------------

The x86 architecture includes instructions that determine 
	the positions of the least significant set bit and 
	the most significant set bit in a word.

Implementing the same operation in C require a loop and a bit shift.

bsrl
----------

Instruction computes the position of most significant bit set in first operand, places the bit position into second operand.

Theory2:
Output Operand
---------------

lvalues where the result should be stored at the end of the operation

The constraint string of an output must be prefixed with either = or +.

= means that the output is write-only

+ means that the output is actually a read-write value.

Theory3:
Constraint String
-----------------

A constraint is a string which specifies placement of an operand.

For example the value of an operand may be 

	written to a processor register (which register to choose) or 

	read from memory etc.


r: The operand is stored in a general-purpose register. 
	GCC can choose any register here


Constraints may also have modifiers which provide additional control over the behavior of the operands

=: Operand is write-only
+: Operand is both read and written
&: Operand is clobbered early

Code Explanation
----------------

This code copies the value of a to b

The code makes use of an
	input register (%1)
	output register (%0)
	temporary register (%%eax)

The input and output register are selected by the compiler and are denoted as %1  and %0 in the assembler code

The name of the temporary register must be specified explicitl. Our example used eax.

Recall that two percent symbols must be entered in the source code in order to produce one percent symbol in the compiler output, which is why the register is given as %%eax.

Generated Assembly Output
--------------------------

	movl	$2, -8(%rbp)
	movl	-8(%rbp), %edx
#APP
# 8 "userprog.c" 1
	movl %edx, %eax
movl %eax, %edx
# 0 "" 2
#NO_APP
	movl	%edx, -4(%rbp)
	movl	-8(%rbp), %eax

The compiler first copies the value of the local  variable a held at position rbp -8 into register edx

The assembly code we included is clearly indicated by the compiler, between the #APP and #NO_APP delimiters.

The assembler code is executed and copies the value (pointlessly) into register eax;

The next statement copies it back to edx register

Next it copies the result back to rbp - 4 which is the address of b.
